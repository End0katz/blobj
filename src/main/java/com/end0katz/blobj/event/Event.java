package com.end0katz.blobj.event;

import java.util.*;
import java.util.function.*;

import java.lang.reflect.*;

import com.end0katz.blobj.*;

/**
 * Event that you can subscribe to. To add your method to an event, run:
 * {@code eventInstance.add(YourClass::YourMethod)}.
 *
 * There are more complex methods of doing this (see
 * src/main/resources/docs/Event.md)
 *
 * Creating an event is done through {@link Event#builder()}
 *
 * @see Subscribe
 */
public class Event {

    /**
     * The default reason string passed to the {@link EventTriggerContext} for
     * each activation, when none is provided.
     */
    public static final String DEFAULT_REASON = "$null";

    /**
     * The maximum number of methods that can be subscribed to a thread. Further
     * Event.add() methods will raise {@link IllegalStateException}
     *
     * @see Event.EventBuilder#subscribeLimit(long)
     */
    protected long maxSubs;
    /**
     * The maximum number of times this event can be activated. Further
     * activations will raise {@link IllegalStateException}
     *
     * @see Event.EventBuilder#triggerLimit(long)
     * @see Event.EventBuilder#singleton()
     * @see Event#activations
     */
    protected long maxTriggers;
    /**
     * The list of methods to be invoked when the {@link Event} is triggered.
     */
    protected final List<Consumer<EventTriggerContext>> subscribers = new ArrayList<>();
    /**
     * The number of times this event has been triggered.
     *
     * @see Event#maxTriggers
     */
    protected long activations = 0l;
    /**
     * The name of the exception, used for the {@link Subscribe} annotation and
     * {@link EventTriggerContext} parameter.
     */
    protected final String name;

    /**
     * Create a {@link Builder} for an {@link Event}.
     *
     * @return a new {@link EventBuilder}.
     */
    public static EventBuilder builder() {
        return new EventBuilder();
    }

    /**
     * Builder for instances of {@link Event}. (you have to use this because the
     * constructor for event is private >:)
     *
     * @see Event#builder()
     */
    public static class EventBuilder implements Builder<Event> {

        /**
         * Construct an {@link EventBuilder} with default values.
         */
        protected EventBuilder() {
        }

        /**
         * The index of the {@link Event}. This is used for the default name
         * generator.
         */
        static int index = 0;

        /**
         * The name of the planned {@link Event}.
         */
        String name = null;
        /**
         * The trigger limit of the planned {@link Event}.
         */
        long triggerLimit = -1;
        /**
         * The subscribe limit of the planned {@link Event}.
         */
        long subscribeLimit = -1;

        /**
         * Set the trigger limit of the planned {@link Event}.
         *
         * @param limit the planned limit.
         * @return {@code this}
         */
        public EventBuilder triggerLimit(long limit) {
            triggerLimit = limit;
            return this;
        }

        /**
         * Set the subscription limit of the planned {@link Event}.
         *
         * @param limit the planned limit.
         * @return {@code this}
         */
        public EventBuilder subscribeLimit(long limit) {
            subscribeLimit = limit;
            return this;
        }

        /**
         * Turns this event into a singleton htat can only be triggered once.
         *
         * @return {@code this}
         * @see EventBuilder#subscribeLimit(long)
         * @future.apiNote this is the same as calling
         * {@code EventBuilder.subscribeLimit(1l);}
         */
        public EventBuilder singleton() {
            return triggerLimit(1);
        }

        /**
         * Set the name of the planned {@link Event}.
         *
         * @param str the planned name.
         * @return {@code this}
         */
        public EventBuilder name(String str) {
            this.name = str;
            return this;
        }

        /**
         * {@inheritDoc}
         *
         * The name will be autogenerated if not provided.
         *
         * @future.implNote the name is generated with
         * <strong>Event#<i>index</i></strong>
         */
        @Override
        public Event build() {
            if (name == null) {
                name = "Event#%s".formatted(index++);
            }

            Event result = new Event(name, triggerLimit, subscribeLimit);
            /*
            if (allEvents.containsKey(name)) {
                System.out.println(allEvents);
                System.out.println(name);
                throw new IllegalArgumentException("Event '%s' already exists! (make sure to namespace your events)".formatted(
                        this.name));
            }
            allEvents.put(name, result);*/

            return result;
        }
    }

    /**
     * Construct an event.
     *
     * @param name the name of the event.
     * @param triggerLimit the max times the event can be triggered, -1 to
     * disable.
     * @param subscribeLimit the max subscriber count, - to disable.
     *
     * @see Event#builder()
     * @see Event.EventBuilder
     */
    private Event(String name, long triggerLimit, long subscribeLimit) {
        maxSubs = subscribeLimit;
        maxTriggers = triggerLimit;
        this.name = name;
    }

    /**
     * Add a method to be run on the event's triggering.
     *
     * @param f the function to be added.
     * @return {@code this}
     *
     * @see Event#add(Runnable)
     * @see Event#add(Class)
     * @see Event#add(Object)
     */
    public Event add(Consumer<EventTriggerContext> f) {
        if (maxSubs == -1 || subscribers.size() < maxSubs) {
            subscribers.add(f);
        } else {
            throw new IllegalStateException("The subscriber limit has already been reached for event '%s'".formatted(
                    this));
        }
        return this;
    }

    /**
     * Add a method to be run on the event's triggering.
     *
     * @param f the function to be added.
     * @return {@code this}
     *
     * @see Event#add(Consumer)
     * @see Event#add(Class)
     * @see Event#add(Object)
     */
    public Event add(Runnable f) {
        return add((_) -> f.run());
    }

    /**
     * Adds the static methods from {@code cls} annotated with an
     * {@code @Subscribe} whose regex matches this event's {@link Event#name}.
     *
     * @param cls the class
     * @return {@code this}
     *
     * @see Event#add(Runnable)
     * @see Event#add(Consumer)
     * @see Event#add(Object)
     * @see Subscribe
     */
    public Event add(Class<?> cls) {
        List<Method> methodsToAdd = new ArrayList<>();
        Class<Subscribe> subscribeAnnotation = Subscribe.class;

        for (Method m : cls.getDeclaredMethods()) {
            if (Modifier.isStatic(m.getModifiers())
                    && m.isAnnotationPresent(subscribeAnnotation)) {
                Subscribe subdat = m.getAnnotation(subscribeAnnotation);
                if (this.name.matches(subdat.value())) {
                    if (m.getParameterCount() > 0
                            && !Arrays.equals(m.getParameters(), new Class<?>[]{EventTriggerContext.class})) {
                        throw new IllegalArgumentException(
                                "%s is annotated with @Subscribe but does not require correct arguments. (required: EventTriggerContext or none)"
                                        .formatted(m));
                    }
                    methodsToAdd.add(m);
                }
            }
        }

        for (Method m : methodsToAdd) {
            if (m.getParameterCount() == 0) {
                this.add(() -> {
                    try {
                        m.invoke(null);
                    } catch (IllegalAccessException | InvocationTargetException e) {
                    }
                });
            } else {
                this.add((context) -> {
                    try {
                        m.invoke(null, context);
                    } catch (IllegalAccessException | InvocationTargetException e) {
                    }
                });
            }
        }

        return this;
    }

    /**
     * Adds the instance methods from {@code inst} annotated with an
     * {@code @Subscribe} whose regex matches this event's {@link Event#name}.
     *
     * @param inst the class
     * @return {@code this}
     *
     * @see Event#add(Runnable)
     * @see Event#add(Consumer)
     * @see Event#add(Class)
     * @see Subscribe
     */
    public Event add(Object inst) {
        List<Method> methodsToAdd = new ArrayList<>();
        Class<Subscribe> subscribeAnnotation = Subscribe.class;

        for (Method m : inst.getClass().getDeclaredMethods()) {
            if (!Modifier.isStatic(m.getModifiers())
                    && m.isAnnotationPresent(subscribeAnnotation)) {
                Subscribe subdat = m.getAnnotation(subscribeAnnotation);
                if (this.name.matches(subdat.value())) {
                    if (m.getParameterCount() > 0
                            && !Arrays.equals(m.getParameters(), new Class<?>[]{EventTriggerContext.class})) {
                        throw new IllegalArgumentException(
                                "%s is annotated with @Subscribe but does not require correct arguments. (required: EventTriggerContext or none)"
                                        .formatted(m));
                    }
                    methodsToAdd.add(m);
                }
            }
        }

        for (Method m : methodsToAdd) {
            if (m.getParameterCount() == 0) {
                this.add(() -> {
                    try {
                        m.invoke(inst);
                    } catch (IllegalAccessException | InvocationTargetException e) {
                    }
                });
            } else {
                this.add((context) -> {
                    try {
                        m.invoke(inst, context);
                    } catch (IllegalAccessException | InvocationTargetException e) {
                    }
                });
            }
        }

        return this;
    }

    /**
     * Trigger this event, in series, in this {@link Thread}, with the
     * <strong>default reason</strong>.
     *
     * @param params the parameters to pass to any
     * {@link EventTriggerContext}-accepting methods.
     * @return {@code this}
     *
     * @see Event#DEFAULT_REASON
     */
    public Event triggerInThisThread(Object... params) {
        return triggerInThisThread(DEFAULT_REASON, params);
    }

    /**
     * Trigger this event, in series, in a new {@link Thread}, with the
     * <strong>default reason</strong>.
     *
     * @param params the parameters to pass to any
     * {@link EventTriggerContext}-accepting methods.
     * @return the new thread.
     *
     * @see Event#DEFAULT_REASON
     */
    public Thread triggerSerial(Object... params) {
        return triggerSerial(DEFAULT_REASON, params);
    }

    /**
     * Trigger this event, in parallel, in a set of newly created
     * {@link Thread}s, with the <strong>default reason</strong>.
     *
     * @param params the parameters to pass to any
     * {@link EventTriggerContext}-accepting methods
     * @return the array of threads created.
     *
     * @see Event#DEFAULT_REASON
     */
    public Thread[] trigger(Object... params) {
        return trigger(DEFAULT_REASON, params);
    }

    /**
     * Trigger this event, in series, in this {@link Thread}, with a custom
     * reason.
     *
     * @param reason the custom reason.
     * @param params the parameters to pass to any
     * {@link EventTriggerContext}-accepting methods.
     * @return {@code this}
     */
    public Event triggerInThisThread(String reason, Object... params) {
        if (maxTriggers > -1 && activations >= maxTriggers) {
            throw new IllegalStateException("The activation limit has already been reached for event '%s'".formatted(
                    this));
        } else if (maxSubs > -1 && subscribers.size() > maxSubs) {
            throw new IllegalStateException("The subscriber limit for %s was exceeded - refusing to trigger.".formatted(
                    this));
        }
        activations++;
        EventTriggerContext context = new EventTriggerContext(this, this.name, reason, params);
        for (Consumer<EventTriggerContext> f : subscribers) {
            f.accept(context.clone());
        }
        return this;
    }

    /**
     * Trigger this event, in series, in a new {@link Thread}, with a custom
     * reason.
     *
     * @param reason the custom reason.
     * @param params the parameters to pass to any
     * {@link EventTriggerContext}-accepting methods.
     * @return the new thread.
     *
     * @see Event#DEFAULT_REASON
     */
    public Thread triggerSerial(String reason, Object... params) {
        if (maxTriggers > -1 && activations >= maxTriggers) {
            throw new IllegalStateException("The activation limit has already been reached for event '%s'".formatted(
                    this));
        } else if (maxSubs > -1 && subscribers.size() > maxSubs) {
            throw new IllegalStateException("The subscriber limit for %s was exceeded - refusing to trigger.".formatted(
                    this));
        }
        Thread result = new Thread(() -> this.triggerInThisThread(reason, params), "blobj:Event '%s'".formatted(this));
        result.start();
        return result;
    }

    /**
     * Trigger this event, in parallel, in a set of newly created
     * {@link Thread}s, with a custom reason/
     *
     * @param reason the custom reason.
     * @param params the parameters to pass to any
     * {@link EventTriggerContext}-accepting methods
     * @return the array of threads created.
     */
    public Thread[] trigger(String reason, Object... params) {
        if (maxTriggers > -1 && activations >= maxTriggers) {
            throw new IllegalStateException("The activation limit has already been reached for event '%s'".formatted(
                    this));
        } else if (maxSubs > -1 && subscribers.size() > maxSubs) {
            throw new IllegalStateException("The subscriber limit for event '%s' was exceeded - refusing to trigger.".formatted(
                    this));
        }

        List<Thread> result = new ArrayList<>();

        activations++;

        EventTriggerContext context = new EventTriggerContext(this, this.name, reason, params);

        int i = 0;
        for (Consumer<EventTriggerContext> f : subscribers) {
            result.add(new Thread(() -> f.accept(context), "blobj:Event '%s' task#%s".formatted(this, (Integer) i++)));
        }
        Thread[] resultAsArr = new Thread[result.size()];

        result.forEach(new Consumer<Thread>() {
            int i = 0;

            @Override
            public void accept(Thread x) {
                x.start();
                resultAsArr[i++] = x;
            }
        });
        return resultAsArr;
    }

    @Override
    public String toString() {
        return name;
    }
}
